---
title: Rate Limits
description: API rate limits and best practices
---

The API enforces rate limits to ensure fair usage and prevent abuse.

## Rate Limits by Endpoint

| Endpoint | Limit | Purpose |
|----------|-------|---------|
| `POST /wallets` | 10/min | Wallet creation is resource-intensive |
| `POST /addresses` | 30/min | Address generation requires HD derivation |
| `POST /webhooks` | 5/min | Webhook config changes are infrequent |
| All other endpoints | 100/min | Default rate limit |

---

## Rate Limit Headers

All responses include rate limit headers:

```
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1705764000
```

| Header | Description |
|--------|-------------|
| `X-RateLimit-Limit` | Maximum requests per window |
| `X-RateLimit-Remaining` | Remaining requests in window |
| `X-RateLimit-Reset` | Unix timestamp when window resets |

---

## Rate Limit Response

When rate limited, you receive a `429 Too Many Requests` response:

```json
{
  "error": "Rate limit exceeded: 10 per 1 minute"
}
```

Wait until the rate limit window resets before retrying.

---

## Best Practices

### 1. Use Batch Endpoints

Instead of creating addresses one by one:

```bash
# Bad: 100 requests
POST /addresses {"chain": "eth", "external_id": "user_001"}
POST /addresses {"chain": "eth", "external_id": "user_002"}
...
```

Use batch creation:

```bash
# Good: 1 request
POST /addresses/batch {
  "addresses": [
    {"chain": "eth", "external_id": "user_001"},
    {"chain": "eth", "external_id": "user_002"},
    ...
  ]
}
```

### 2. Cache Responses

Address data doesn't change. Cache it:

```python
from functools import lru_cache

@lru_cache(maxsize=10000)
def get_user_address(external_id: str, chain: str):
    return api.get_or_create_address(chain, external_id)
```

### 3. Use Webhooks

Instead of polling for payments:

```bash
# Bad: Constant polling
while True:
    GET /payments?external_id=user_123&status=confirmed
    sleep(5)
```

Use webhooks:

```python
# Good: Real-time notifications
@app.post("/webhook")
def handle_payment(payload):
    if payload["event"] == "payment.confirmed":
        process_payment(payload["data"])
```

### 4. Implement Exponential Backoff

```python
import time

def api_request_with_retry(func, max_retries=5):
    for attempt in range(max_retries):
        response = func()

        if response.status_code == 429:
            retry_after = response.json()["error"]["details"]["retry_after"]
            time.sleep(retry_after)
            continue

        return response

    raise Exception("Max retries exceeded")
```

---

## Increasing Limits

Contact support if you need higher rate limits for your use case.
